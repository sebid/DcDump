#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.3 on Sat Sep 03 16:41:45 2011
"""
    Primarily handles the main user interface, classes etc are auto generated by wxGlade.
"""


import wx
import Chars, os.path, datetime
import Threadz
import Queue
import WhoIs
import Scripts
# begin wxGlade: extracode
# end wxGlade

from DebugSettings import Debug


class Diag_Tab2EditName(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: Diag_Tab2EditName.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_1 = wx.StaticText(self, -1, "Session name:")
        self.edit_name = wx.TextCtrl(self, -1, "")
        self.button_2 = wx.Button(self, -1, "Save")
        self.button_3 = wx.Button(self, -1, "Cancel")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.ButtonSave, self.button_2)
        self.Bind(wx.EVT_BUTTON, self.ButtonCancel, self.button_3)
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: Diag_Tab2EditName.__set_properties
        self.SetTitle("Edit session name")
        self.edit_name.SetToolTipString("Custom session name.. (easier to remember?)")
        self.button_2.SetMinSize((-1, 20))
        self.button_2.SetToolTipString("Store new session name")
        self.button_3.SetMinSize((-1, 20))
        self.button_3.SetToolTipString("Keep current name")
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: Diag_Tab2EditName.__do_layout
        grid_sizer_3 = wx.GridSizer(3, 2, 0, 0)
        grid_sizer_3.Add(self.label_1, 0, 0, 0)
        grid_sizer_3.Add((5, 20), 0, 0, 0)
        grid_sizer_3.Add(self.edit_name, 0, 0, 0)
        grid_sizer_3.Add((5, 20), 0, 0, 0)
        grid_sizer_3.Add(self.button_2, 0, 0, 0)
        grid_sizer_3.Add(self.button_3, 0, 0, 0)
        self.SetSizer(grid_sizer_3)
        grid_sizer_3.Fit(self)
        self.Layout()
        # end wxGlade

    def ButtonSave(self, event): # wxGlade: Diag_Tab2EditName.<event_handler>
        self.SetReturnCode(wx.ID_OK)
        self.Destroy()

    def ButtonCancel(self, event): # wxGlade: Diag_Tab2EditName.<event_handler>
        self.SetReturnCode(wx.ID_CANCEL)
        self.Destroy()
        
    def SetName(self, name):
        self.edit_name.SetLabel(name)
                
    def GetName(self):
        return self.edit_name.GetLabel()

# end of class Diag_Tab2EditName


class MyDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: MyDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.listPOP_copy = wx.ListCtrl(self, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
        self.buttonPOP_exit_copy = wx.Button(self, -1, "Return / Exit")
        self.label_22_copy_1 = wx.StaticText(self, -1, "ID:")
        self.textPOP_id_copy = wx.TextCtrl(self, -1, "")
        self.label_22_copy_2_copy = wx.StaticText(self, -1, "Account:")
        self.textPOP_account = wx.TextCtrl(self, -1, "")
        self.label_22_copy_2 = wx.StaticText(self, -1, "Character:")
        self.textPOP_toon_copy = wx.TextCtrl(self, -1, "")
        self.label_3 = wx.StaticText(self, -1, "Dimension:")
        self.choicePOP_dimension = wx.Choice(self, -1, choices=["Atlantean (RK1)", "Rimor (RK2)"])
        self.buttonPOP_enable_copy = wx.Button(self, -1, "Enable")
        self.buttonPOP_disable_copy = wx.Button(self, -1, "Disable")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.didDeSelect, self.listPOP_copy)
        self.Bind(wx.EVT_LIST_ITEM_SELECTED, self.didSelect, self.listPOP_copy)
        self.Bind(wx.EVT_LIST_COL_CLICK, self.doSort, self.listPOP_copy)
        self.Bind(wx.EVT_CHOICE, self.SelectDimension, self.choicePOP_dimension)
        # end wxGlade
        

        
        # Enable the buttons etc
        self.Bind(wx.EVT_BUTTON, self.ButtonEnable, self.buttonPOP_enable_copy)
        self.Bind(wx.EVT_BUTTON, self.ButtonDisable, self.buttonPOP_disable_copy)
        self.Bind(wx.EVT_BUTTON, self.ButtonExit, self.buttonPOP_exit_copy)
        
        self.textPOP_toon_copy.Enable(False)
        
        

        # Small array for inverting sort on list
        # 1: No invert, -1 inverted
        self.sortInvert = (1, 1, 1, 1)
        
        # Record if any actual changes has been made
        self.modifiedDict = {}

        # Enable ESC to exit
        self.listPOP_copy.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        #self.textPOP_toon_copy.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.buttonPOP_enable_copy.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.buttonPOP_disable_copy.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.buttonPOP_exit_copy.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        self.choicePOP_dimension.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        
        self.Bind(wx.EVT_KEY_UP, self.OnKeyUp)
        
        # Just make sure it exists..
        self.__ThreadDBSave = 0
        
        
        
    def OnKeyUp(self, event): 
        keyCode = event.GetKeyCode()
        if keyCode == wx.WXK_ESCAPE:
            if self.__ThreadDBSave != 0:
                while (self.__ThreadDBSave.isAlive()): continue
            self.Close()
    
    # Update listview, after a change to name or Enabled status
    def UpdateListview(self):
        # Update multi-select
        selection = self.getCurrentSelection(idList=True)
        for ID, idx in selection:
            if self.toonDict[ID]["Enabled"]:   en = "Yes"
            else:                              en = "No"
            self.listPOP_copy.SetStringItem(idx, 2, "%s" % self.toonDict[ID]["Toon"])
            self.listPOP_copy.SetStringItem(idx, 3, en)

       
       
        
    def getCurrentSelection(self, idList=False):
        # Get multi-selection
        selection = []
        next = self.listPOP_copy.GetFirstSelected()
        while next != -1:
            id = int(self.listPOP_copy.GetItem(next, 0).GetText())
            if idList: selection.append((id, next))
            else: selection.append(id)
            next = self.listPOP_copy.GetNextSelected(next)
                
        return selection
        
    # Enable toon (SQL update & button swap)
    def ButtonEnable(self, event):
        # Get multi-selection
        selection = self.getCurrentSelection()
        
        # Only bother with the buttons if its a single-item.
        if len(selection) == 1:
            self.buttonPOP_enable_copy.Enable(False)
            self.buttonPOP_disable_copy.Enable(True)
            
        
        for ID in selection:
            # Skip toons with no names, or already enabled.
            if not self.toonDict[ID]["Toon"] or self.toonDict[ID]["Enabled"]:
                print "[Manage ] Enable: Ignored ID %d" % ID
                continue
            print "[Manage ] Enabling ID %d" % ID
            
            self.modifiedDict[ID] = 1
            print "[Manage ] Enable successful"
                
            self.toonDict[ID]["Enabled"] = 1
    
        # Update view
        print "[Manage ] Updating listview.."
        self.UpdateListview()
       
    # Disable toon (SQL update & button swap)
    def ButtonDisable(self, event):
        # Get multi-selection
        selection = self.getCurrentSelection()
        
        # Only bother with the buttons if its a single-item.
        if len(selection) == 1:
            self.buttonPOP_enable_copy.Enable(True)
            self.buttonPOP_disable_copy.Enable(False)
        
        
        # Update..
        for ID in selection:
            if not self.toonDict[ID]["Toon"] or not self.toonDict[ID]["Enabled"]:
                continue
                    
                    
                    
            self.toonDict[ID]["Enabled"] = 0
            self.modifiedDict[ID] = 1

        self.UpdateListview()
    
    
    def ButtonExit(self, event):
        if self.__ThreadDBSave != 0:
            while (self.__ThreadDBSave.isAlive()): continue
        self.Close()
        
    
    def populate(self, aoPath, aoiaPath):
        self.aoPath = aoPath
        self.aoiaPath = aoiaPath

        
        # Load char data from SQL
        toonsDict = Chars.LoadToonsDB()
        modified = [] # Modified toon data, for storing.
          
        # Detect which characters, if any, are missing an account name.
        missingAccount = []
        for ID in toonsDict:
            if not toonsDict[ID]["Acc"]: missingAccount.append(ID)
        
        if len(missingAccount): print "[UI     ] Missing account name for %d toons" % len(missingAccount)
        


        # Grab account names from Prefs
        folderDict = Chars.GetAccFromID(False)
        for ID in folderDict:
            if ID in missingAccount: 
                missingAccount.remove(ID)                   # No longer missing
                toonsDict[ID]["Acc"] = folderDict[ID]       # Store acc name
                modified.append(ID)
                print "Got accname for ID=%d" % ID
                
            # Store newly found acc/ids
            if ID not in toonsDict:
                toonsDict[ID] = {"Toon":"", "Enabled": 0, "Acc":folderDict[ID], "Dimension":"RK1"}
                modified.append(ID)
                

        
        
        # Look for deleted toons..
        for ID in toonsDict:
            if ID not in folderDict:
                missingAccount.append(ID)
                
        
        # Grab character names from aoia
        # Overwrite only if no name currently exists
        aoiaDict = Chars.GetIdToonFromAOIA(self.aoiaPath)
        for ID in aoiaDict:
            if not ID in toonsDict: continue
            if not toonsDict[ID]["Toon"]:
                print "%d: Got new name from AOIA: %s" % (ID, aoiaDict[ID])     
                toonsDict[ID]["Toon"] = aoiaDict[ID]
                print toonsDict[ID]
                modified.append(ID)
                
        
                
       # Convert to dict for storing (seperate from self.modifiedDict, for now anyhow)
        modifiedDict = {}
        for ID in modified: modifiedDict[ID] = toonsDict[ID] 
                    
        # Delete any toons still without any account name
        for ID in missingAccount:
            del toonsDict[ID]
            modifiedDict[ID] = None
            print "Deleted toon with missing account data: %d" % ID
        
        
        import time
             
        # Store any changes
        self.__ThreadDBSave = Chars.DBThread(modifiedDict)
        self.__ThreadDBSave.start()
        #Chars.SaveToonsDB(modifiedDict)
        
        s = time.time()
        
        
        
        # Add tabs to list control
        self.listPOP_copy.InsertColumn(0, "ID", width=80)
        self.listPOP_copy.InsertColumn(1, "Account", width=100)
        self.listPOP_copy.InsertColumn(2, "Toon", width=100)
        self.listPOP_copy.InsertColumn(3, "Enabled", width=60)
        

            
        # Populate the damn list control
        self.toonDict = toonsDict
        self.sortDict = {}
        i = 0
        for K in toonsDict:
            if not toonsDict[K]["Toon"]: continue
            # Enabled or not
            if toonsDict[K]["Enabled"]: 
                en = "Yes"
                loc = 0 
            else: en = "No"; loc = i
            
            self.listPOP_copy.InsertStringItem(loc, "%s" % K)
            self.listPOP_copy.SetStringItem(loc, 1, "%s" % toonsDict[K]["Acc"])
            self.listPOP_copy.SetStringItem(loc, 2, "%s" % toonsDict[K]["Toon"])
            self.listPOP_copy.SetStringItem(loc, 3, en)
            self.listPOP_copy.SetItemData(loc, K % 10000000)
            self.sortDict[K % 10000000] = K
            
            i += 1
            
        if time.time() - s > 1:
            print "Took %g seconds to populate list" % (time.time() - s)
            
        self.listPOP_copy.SortItems(self.mySortFunc_toon)
        return len(modifiedDict) != 0


    def mySortFunc_acc(self, a, b):
        # Count no-name as the last desirable result
        if not self.toonDict[ self.sortDict[a] ]["Acc"]: return 1 * self.sortInvert[1]
        if not self.toonDict[ self.sortDict[b] ]["Acc"]: return -1 * self.sortInvert[1]
        
        # Sort by acc name
        if self.toonDict[ self.sortDict[a] ]["Acc"] < self.toonDict[ self.sortDict[b] ]["Acc"]:
            return -1 * self.sortInvert[1]
        elif self.toonDict[ self.sortDict[a] ]["Acc"] > self.toonDict[ self.sortDict[b] ]["Acc"]:
            return 1 * self.sortInvert[1]
        else:
            return 0
    
    
    def mySortFunc_toon(self, a, b):
        # Count no-name as the last desirable result
        if not self.toonDict[ self.sortDict[a] ]["Toon"]: return 1 * self.sortInvert[2]
        if not self.toonDict[ self.sortDict[b] ]["Toon"]: return -1 * self.sortInvert[2]
        
        # Sort by toon name
        if self.toonDict[ self.sortDict[a] ]["Toon"] < self.toonDict[ self.sortDict[b] ]["Toon"]:
            return -1 * self.sortInvert[2]
        elif self.toonDict[ self.sortDict[a] ]["Toon"] > self.toonDict[ self.sortDict[b] ]["Toon"]:
            return 1 * self.sortInvert[2]
        else:
            return 0
        
    # Sort based on "Enabled" parameter
    # If both are enabled, sort by toon name
    def mySortFunc_enabled(self, a, b):
        if self.toonDict[ self.sortDict[a] ]["Enabled"] and self.toonDict[ self.sortDict[b] ]["Enabled"]:
            return self.mySortFunc_toon(a, b)
        elif self.toonDict[ self.sortDict[a] ]["Enabled"]:
            return -1 * self.sortInvert[3]
        else:
            return 1 * self.sortInvert[3]
        

    def __set_properties(self):
        # begin wxGlade: MyDialog.__set_properties
        self.SetTitle("Character Managment")
        self.listPOP_copy.SetMinSize((380, 300))
        self.buttonPOP_exit_copy.SetMinSize((92, 20))
        self.textPOP_id_copy.Enable(False)
        self.textPOP_account.Enable(False)
        self.label_22_copy_2.SetToolTipString("Character name")
        self.textPOP_toon_copy.SetToolTipString("Character name")
        self.textPOP_toon_copy.Enable(False)
        self.choicePOP_dimension.SetSelection(0)
        self.buttonPOP_enable_copy.SetMinSize((-1, 20))
        self.buttonPOP_enable_copy.SetToolTipString("Activates logging")
        self.buttonPOP_enable_copy.Enable(False)
        self.buttonPOP_disable_copy.SetMinSize((-1, 20))
        self.buttonPOP_disable_copy.SetToolTipString("Disables logging")
        self.buttonPOP_disable_copy.Enable(False)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MyDialog.__do_layout
        sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_2 = wx.GridSizer(9, 3, 0, 0)
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_2.Add(self.listPOP_copy, 1, wx.EXPAND, 0)
        sizer_2.Add(self.buttonPOP_exit_copy, 0, 0, 0)
        sizer_1.Add(sizer_2, 1, wx.EXPAND, 0)
        grid_sizer_2.Add(self.label_22_copy_1, 0, 0, 0)
        grid_sizer_2.Add(self.textPOP_id_copy, 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add(self.label_22_copy_2_copy, 0, 0, 0)
        grid_sizer_2.Add(self.textPOP_account, 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add(self.label_22_copy_2, 0, 0, 0)
        grid_sizer_2.Add(self.textPOP_toon_copy, 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add(self.label_3, 0, 0, 0)
        grid_sizer_2.Add(self.choicePOP_dimension, 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add(self.buttonPOP_enable_copy, 0, 0, 0)
        grid_sizer_2.Add(self.buttonPOP_disable_copy, 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        grid_sizer_2.Add((10, 20), 0, 0, 0)
        sizer_1.Add(grid_sizer_2, 1, 0, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade
        
    def doSort(self, event): # wxGlade: MyDialog.<event_handler>
        if event.Column == 0:            return
        elif event.Column == 1:          self.listPOP_copy.SortItems(self.mySortFunc_acc)
        elif event.Column == 2:          self.listPOP_copy.SortItems(self.mySortFunc_toon)
        else:                            self.listPOP_copy.SortItems(self.mySortFunc_enabled)
        
        # Flip sorting, restore other idx sorts to default
        # And set current to "flip"
        idx = event.Column
        if idx == 1: self.sortInvert = (1, self.sortInvert[1] * -1, 1, 1)
        elif idx == 2 or idx == 0: self.sortInvert = (1, 1, self.sortInvert[2] * -1, 1)
        else: self.sortInvert = (1, 1, 1, self.sortInvert[3] * -1)


    def didDeSelect(self, event): # wxGlade: MyDialog.<event_handler>
        if len(self.getCurrentSelection()) >= 1:
            self.didSelect(event)
            
        # Disable everything, no selection.
        else:
            self.buttonPOP_enable_copy.Enable(False)
            self.buttonPOP_disable_copy.Enable(False)


    def didSelect(self, event): # wxGlade: MyDialog.<event_handler>
        # For multi select, simply allow enable/disable
        selection = self.getCurrentSelection(idList=True)
        if len(selection) > 1:
            self.buttonPOP_enable_copy.Enable(True)
            self.buttonPOP_disable_copy.Enable(True)
            return
        
        elif len(selection) == 0:
            self.buttonPOP_enable_copy.Enable(False)
            self.buttonPOP_disable_copy.Enable(False)
            return
        
              
        key, idx = selection[0]
        #key = self.listPOP_copy.GetItem(idx, 0).GetText()
        self.textPOP_id_copy.SetLabel("%s" % key)
        
        self.textPOP_account.SetLabel("%s" % self.toonDict[key]["Acc"])
        self.textPOP_toon_copy.SetLabel("%s" % self.toonDict[key]["Toon"])
        if self.toonDict[key]["Dimension"] == 'RK1': self.choicePOP_dimension.SetSelection(0)
        else: self.choicePOP_dimension.SetSelection(1)
        
        if self.toonDict[key]["Toon"]:
            enabled = self.toonDict[key]["Enabled"]
            self.buttonPOP_enable_copy.Enable(not enabled)
            self.buttonPOP_disable_copy.Enable(enabled)         
        

    def Diag_help(self, event): # wxGlade: MyDialog.<event_handler>
        x = wx.MessageDialog(None, """
        Each ID corresponds to an ingame character.
        If you have Item Assistant installed, this is done automatically.
        
        To Manually find a toons character ID:
        1) Ingame press Shift+F9.
        2) Look at the second to last line
        3) Look for "character id: 50000:2192247310"
        -- In this case, the character ID is 2192247310.
        
        4) Select ID 2192247310 in the DDParser
        5) Write down the toons name in the edit field.
        """
        , "Help", style=wx.OK | wx.CENTRE)
        x.ShowModal()
        


    def SelectDimension(self, event=666): # wxGlade: MyDialog.<event_handler>
        if event == 666:
            return
        dim = "RK1"
        if self.choicePOP_dimension.GetSelection() > 0:
            dim = "RK2"
            
        selection = self.getCurrentSelection()
        for ID in selection:
            self.toonDict[ID]["Dimension"] = dim
            print "[UI     ] Set dimension=%s for toon %s" % (dim, self.toonDict[ID]["Toon"])
            self.modifiedDict[ID] = 1


# end of class MyDialog


























class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: MyFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.frame_1_menubar = wx.MenuBar()
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(1, "Exit", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "File")
        wxglade_tmp_menu = wx.Menu()
        wxglade_tmp_menu.Append(wx.NewId(), "Help", "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.Append(2, "About", "", wx.ITEM_NORMAL)
        self.frame_1_menubar.Append(wxglade_tmp_menu, "About")
        self.SetMenuBar(self.frame_1_menubar)
        # Menu Bar end
        self.frame_1_statusbar = self.CreateStatusBar(1, 0)
        self.notebook_1_copy = wx.Notebook(self, -1, style=0)
        self.notebook_1_pane_1_copy = wx.Panel(self.notebook_1_copy, -1)
        self.label_21_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "Characters:")
        self.listbox1_toonlist = wx.ListBox(self.notebook_1_pane_1_copy, -1, choices=[])
        self.button1_manage = wx.Button(self.notebook_1_pane_1_copy, -1, "Manage")
        self.button1_latest = wx.Button(self.notebook_1_pane_1_copy, -1, "Latest")
        self.label_11_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "Selected")
        self.label_12_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "ID:")
        self.label1_showid = wx.StaticText(self.notebook_1_pane_1_copy, -1, "")
        self.label_13_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "Character:")
        self.label1_showtoon = wx.StaticText(self.notebook_1_pane_1_copy, -1, "")
        self.label_14_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "Level:")
        self.label1_showlevel = wx.StaticText(self.notebook_1_pane_1_copy, -1, "")
        self.label_18_copy = wx.StaticText(self.notebook_1_pane_1_copy, -1, "Profession:")
        self.label1_showclass = wx.StaticText(self.notebook_1_pane_1_copy, -1, "")
        self.button1_parse = wx.Button(self.notebook_1_pane_1_copy, -1, "Parse now")
        self.button1_pause = wx.Button(self.notebook_1_pane_1_copy, -1, "Pause")
        
        self.notebook_1_pane_2_copy = wx.Panel(self.notebook_1_copy, -1)
        self.listbox2_history = wx.ListBox(self.notebook_1_pane_2_copy, -1, choices=[])
        self.button_4_copy = wx.Button(self.notebook_1_pane_2_copy, -1, "Show latest")
        self.tab2_chooseToon = wx.Choice(self.notebook_1_pane_2_copy, -1, choices=[])
        self.tab2_start = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Start")
        self.tab2_out_start = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_end = wx.StaticText(self.notebook_1_pane_2_copy, -1, "End")
        self.tab2_out_end = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_duration = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Duration")
        self.tab2_out_duration = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_name = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Name")
        self.tab2_out_name = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_level = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Level")
        self.tab2_out_level = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_prof = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Profession")
        self.tab2_out_prof = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_dmg = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Damage")
        self.tab2_out_dmg = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_dpm = wx.StaticText(self.notebook_1_pane_2_copy, -1, "DPM")
        self.tab2_out_dpm = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_crit = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Crit")
        self.tab2_out_crit = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_pets = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Pets")
        self.tab2_out_pets = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_charms = wx.StaticText(self.notebook_1_pane_2_copy, -1, "Charms")
        self.tab2_out_charms = wx.StaticText(self.notebook_1_pane_2_copy, -1, "")
        self.tab2_intoao = wx.Button(self.notebook_1_pane_2_copy, -1, "Copy to AO")
        
        self.tab2_editname = wx.Button(self.notebook_1_pane_2_copy, -1, "Edit session")
        self.tab2_delete_log = wx.Button(self.notebook_1_pane_2_copy, -1, "Delete")
        self.notebook_1_pane_3_copy = wx.Panel(self.notebook_1_copy, -1)
        self.label_1_copy = wx.StaticText(self.notebook_1_pane_3_copy, -1, "Path to AO:")
        self.text_ctrl_3_aopath = wx.TextCtrl(self.notebook_1_pane_3_copy, -1, "")
        self.button3_browse_ao = wx.Button(self.notebook_1_pane_3_copy, -1, "Browse..")
        self.button3_autodetect = wx.Button(self.notebook_1_pane_3_copy, -1, "Auto detect..")
        self.label_2 = wx.StaticText(self.notebook_1_pane_3_copy, -1, "Start/Stop Hotkey:")
        self.Tab3_text_hotkeyMod = wx.Choice(self.notebook_1_pane_3_copy, -1, choices=["Control", "Alt", "Shift"])
        self.Tab3_text_hotkey = wx.TextCtrl(self.notebook_1_pane_3_copy, -1, "")
        self.Tab3_pause_instead_of_stop = wx.CheckBox(self.notebook_1_pane_3_copy, -1, "Pause instead of stop")
        self.checkbox_4 = wx.CheckBox(self.notebook_1_pane_3_copy, -1, "Don't ignore mobs")
        self.checkbox_5 = wx.CheckBox(self.notebook_1_pane_3_copy, -1, "Don't exclude players with low damage")
        self.Tab3_Grouptype = wx.Choice(self.notebook_1_pane_3_copy, -1, choices=["Default", "Team", "Raid", "Custom"])
        self.Tab3_Groupname = wx.TextCtrl(self.notebook_1_pane_3_copy, -1, "")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.MenuExit, id=1)
        self.Bind(wx.EVT_MENU, self.MenuHelp, id=-1)
        self.Bind(wx.EVT_MENU, self.MenuAbout, id=2)
        self.Bind(wx.EVT_LISTBOX, self.Listbox1Click, self.listbox1_toonlist)
        self.Bind(wx.EVT_BUTTON, self.Tab1_BPause, self.button1_pause)
        self.Bind(wx.EVT_LISTBOX, self.Tab2SelHistory, self.listbox2_history)
        self.Bind(wx.EVT_BUTTON, self.Tab2_ShowLatest, self.button_4_copy)
        self.Bind(wx.EVT_CHOICE, self.Tab2ChooseToon, self.tab2_chooseToon)
        self.Bind(wx.EVT_BUTTON, self.Tab2_CopyToAO, self.tab2_intoao)
        
        self.Bind(wx.EVT_BUTTON, self.Tab2_EditSession, self.tab2_editname)
        self.Bind(wx.EVT_BUTTON, self.Tab2_DeleteLog, self.tab2_delete_log)
        self.Bind(wx.EVT_BUTTON, self.Tab3_BrowseAO, self.button3_browse_ao)
        self.Bind(wx.EVT_CHOICE, self.Tab3_SetHotkey, self.Tab3_text_hotkeyMod)
        self.Bind(wx.EVT_TEXT, self.Tab3_SetHotkey, self.Tab3_text_hotkey)
        self.Bind(wx.EVT_CHOICE, self.Tab3_GroupType, self.Tab3_Grouptype)
        self.Bind(wx.EVT_TEXT, self.Tab3_GroupName, self.Tab3_Groupname)
        # end wxGlade
        
        
        
        
        # Set program icon *** WARNING: THIS REQUIRES ARG0 TO BE PROGRAM PATH ***
        try:
            from sys import argv
            if ".exe" in argv[0]: icon = wx.Icon(argv[0], wx.BITMAP_TYPE_ICO)
            else: icon = wx.Icon('Client0.ico', wx.BITMAP_TYPE_ICO)
            self.SetIcon(icon)
        except: pass
        

        
        
        # Modules
        self.w = WhoIs.WhoIs('RK1', True)
        self.parser = 0
        self.p_tasks = Queue.Queue()
        self.p_feedback = Queue.Queue()
        self.p_timer = wx.Timer(self, 100)
        self.parserActive = False
        wx.EVT_TIMER(self, 100, self.on_timer)

        
        # On close
        self.Bind(wx.EVT_CLOSE, self.OnClose)



        # Load config from SQL
        self.loadConfig()
        
        
        if not "AOPath" in self._config:        self._config["AOPath"] = ""
        if not "AOIAPath" in self._config:      self._config["AOIAPath"] = ""
        if not "Hotkey_Key" in self._config:    self._config["Hotkey_Key"] = None
        if not "Hotkey_Mod" in self._config:    self._config["Hotkey_Mod"] = None
        
        
        # Launch listener (before Tab1::UpdateTonlist)
        import Listener
        print "Logger initiated.."
        self.__Listener = Listener.Listener(self.frame_1_statusbar)
        print "Logger initiated.."
        
        # Undesirable, would like Listener() to be standalone.
        # Should be fixed in the future
        self.__ListenerTimer = wx.Timer(self, 500)  
        wx.EVT_TIMER(self, 500, self.__Listener.InjectDll)
        self.__ListenerTimer.Start(5 * 1000)

            
        # Tab1 
        self.Bind(wx.EVT_BUTTON, self.Tab1_BManage, self.button1_manage)
        self.Bind(wx.EVT_BUTTON, self.Tab1_BLatest, self.button1_latest)
        self.Bind(wx.EVT_BUTTON, self.Tab1_BParse, self.button1_parse)
        self.Tab1_UpdateToonlist()      # Local list of active toons

                

        
        # Logger
        import Logging
        self.DBLogger = Logging.History()
        
                        
        # Tab 2 (must be after logger)
        self.Tab2PopulateHistory() 
        self.CurrentData = {}
        self.CurrentStats = {}
        self.CurrentPeriod = (0, 0, 0)
        
        # Tab 3; Bind callbacks and verify validity of AO path
        self.Bind(wx.EVT_BUTTON, self.Tab3_AutoDetect_AO, self.button3_autodetect)
        self.Bind(wx.EVT_TEXT, self.Tab3_EditPathAO, self.text_ctrl_3_aopath)
        if os.access(os.path.join(self._config["AOPath"], "Anarchy.exe"), os.F_OK):
            self.text_ctrl_3_aopath.SetLabel(self._config["AOPath"])
        
        
        # Retarded way of resizing the controls
        w, h = self.GetSize()
        self.SetSizeWH(w + 1, h)
        self.Show(True)


        
        
        # Auto detect AO, if path not set
        if not self._config["AOPath"]: self.Tab3_AutoDetect_AO(0)
        
        pathAOIA = Chars.AutodetectAOIA()
        if not pathAOIA == "-1": self._config["AOIAPath"] = pathAOIA
        
        ret = Chars.Initialize(self._config["AOPath"])
        print "[UI/Chars] Initialize chars:", ret
        self.InitializeSQDB(self._config["AOPath"], self._config["AOIAPath"])
        
        
        
        # Anonymous user statistics
        #self.__anonstats = Chars.AnonStats()
        #self.__anonstats.start()
        
        # Register hotkey (triggers twice, for two updates)
        # Important: Register modifier first, as modifier is overwritten when Key changes.
        if self._config["Hotkey_Key"] != None and self._config["Hotkey_Mod"] != None:
            modifDict = {None:0, 'Control':0, 'Alt':1, 'Shift':2}
            
            try:
                self.Tab3_text_hotkeyMod.SetSelection(modifDict[self._config["Hotkey_Mod"]])
                self.Tab3_text_hotkey.SetLabel(self._config["Hotkey_Key"])
            except KeyError:
                pass

        self.__Listener.setAOPath(self._config["AOPath"])
        
        # Grab checkbox settings from DB and tick them off if needed
        for entry in [("AllowMobs", self.checkbox_4), ("AllowLowdmg", self.checkbox_5), ("HotkeyPause", self.Tab3_pause_instead_of_stop)]:
            try: 
                if int(self._config[entry[0]]): 
                    entry[1].SetValue(True)
            except: pass
            
        # Select the default group type
        try: groupType = self._config['GroupType']
        except: 
            groupType = 'Default'
            self._config['GroupType'] = 'Default'
        for i in xrange(0, len(self.Tab3_Grouptype.GetStrings())):
            if self.Tab3_Grouptype.GetString(i) == groupType:
                self.Tab3_Grouptype.SetSelection(i)
                
        # Set the default group name
        try: 
            groupName = self._config['GroupName']
        except: 
            groupName = 'Default'
            self._config['GroupName'] = 'Default'
        self.Tab3_Groupname.SetLabel(groupName)


            
    '''
    Updates the Parse/Pause buttons and title bar
    If the parser is not running, the isPause argument is ignored.
    '''
    def updateUI(self, isParsing, isPaused = False):
        if isParsing and isPaused:
            self.SetLabel("Paused..")
            self.button1_parse.SetLabel("Stop")
            self.button1_pause.SetLabel("Unpause")
            self.button1_pause.Enable(True)
            self.parserActive = True
        elif isParsing:
            self.SetLabel("Parsing..")
            self.button1_parse.SetLabel("Stop")
            self.button1_pause.SetLabel("Pause")
            self.button1_pause.Enable(True)
            self.parserActive = True
        else:
            self.SetLabel("DDParser")
            self.button1_parse.SetLabel("Parse now")
            self.button1_pause.SetLabel("Pause")
            self.button1_pause.Enable(False)
            self.parserActive = False
            

    def on_timer(self, event):
        # Thread dead, stop timer
        if not self.parser.isAlive():
            self.p_timer.Stop()
            self.updateUI(False)
            print "Timer proc: Parse is not alive"
    
        # Read any feedback
        while self.p_feedback.qsize():
            data = self.p_feedback.get()
            if data[0] == "Info":
                self.frame_1_statusbar.SetLabel("Parser: %s" % data[1])
                
            # Error occurred
            elif data[0] == "Error":
                self.frame_1_statusbar.SetLabel("Error: %s" % data[1])
                self.p_timer.Stop()
                self.updateUI(False)
                
            # Parse successful
            elif data[0] == "Data":
                self.p_timer.Stop()
                self.updateUI(False)
                
                stats, data, period, Toon = data[1:]
                if not self.DBLogger.log(period[0], period[1], Toon, str(data), str(stats)):
                    pass #self.frame_1_statusbar.SetLabel("Failed adding data to history (duplicate?)")
                else:
                    self.CurrentData = data # Somewhat redundant, reads from SQL either way.
                    self.CurrentStats = stats
                    self.CurrentPeriod = period
                
                # Erase current tab2 history, switch to tab2 and select most recent
                self.notebook_1_copy.ChangeSelection(1)
                self.Tab2PopulateHistory()
                self.Tab2_ShowLatest(0, (period[0], period[1], Toon))
                
                
            # God knows..
            else:
                print "Unknown message:", data
            
                
        
    def Tab1_BPause(self, event):  # wxGlade: MyFrame.<event_handler>
        self.p_tasks.put("Pause")
        if not 'Unpause' in self.button1_pause.GetLabel():
            self.updateUI(True, True)
        else:
            self.updateUI(True, False)
            

    def Tab1_BParse(self, event):
        # Might be a hotkey pause!
        if event == 'Pause' and self.parserActive:
            self.Tab1_BPause(event)
            return
        
        # If already parsing..
        if self.parserActive:
            self.p_tasks.put("Stop")
            self.updateUI(False)
            return
        

        # Grab log name, verify that it exists
        path = ""
        try:
            accnames = Chars.GetAccFromID(False)
            path = Chars.GetLogfilePath(accnames[self.currentToonID], self.currentToonID)

            if path == None:
                self.frame_1_statusbar.SetLabel("Error: No recent fights found for toon '%s' (no log)" % self.currentToon)
                return
        except KeyError:
                self.frame_1_statusbar.SetLabel('Error: No toon selected?')
                return
        
        # Find out which of the two logs are newest
        print "[UI     ] Parsing log:", path
        
        # Set dimension for whois
        dim = self.activeToons[self.currentToonID]["Dimension"]
        print "[UI     ] Dimension for toon '%s' is %s" % (self.currentToon, dim)
        
        # Start the parser!
        allowMobs   = self.checkbox_4.IsChecked()
        allowLowdmg = self.checkbox_5.IsChecked()
        targetWindow = self._config["GroupType"]
        if targetWindow == 'Custom': targetWindow = self._config["GroupName"]

        self.parser = Threadz.WorkerThread(self._config["AOPath"], self.currentToon, path, self.p_tasks, self.p_feedback, dim, allowMobs, allowLowdmg, targetWindow)
        self.parser.start()
        self.updateUI(True)
        self.parserActive = True
        
        
        self.p_timer.Start(100)

    def Tab1_UpdateToonlist(self):
        # Populate listbox again
        # http://www.velocityreviews.com/forums/t326730-how-to-insert-into-listbox-using-wxpython.html
        self.currentToon = ""
        self.currentToonID = 0
        
        self.listbox1_toonlist.Set([])
        ownToons = []
        self.activeToons = Chars.LoadToonsDB()

        # Append items to list        
        for Key in self.activeToons:
            if self.activeToons[Key]["Enabled"]:
                self.listbox1_toonlist.Append(self.activeToons[Key]["Toon"])
                ownToons.append((self.activeToons[Key]["Toon"], self.activeToons[Key]["Dimension"]))
        
        # Do a mass whois of all toons owned by the user, keeping them up to date.
        self.__whoisWorker = Threadz.WhoIsThread(ownToons)
        self.__whoisWorker.start()
        self.__Listener.AddActives(self.activeToons) # Update listener toon-list
                
                
    # Manage characters
    def Tab1_BManage(self, event):
        if not self._config["AOPath"]:
            x = wx.MessageDialog(None, "Please configure the path to Anarchy Online", "Error", style=wx.OK | wx.CENTRE | wx.ICON_HAND)
            x.ShowModal()
            return
        
        import time
        s = time.time()

        
        # Open dialog for managing chars
        dlg = MyDialog(self)
        needUpdate = dlg.populate(self._config["AOPath"], self._config["AOIAPath"])
        if time.time() - s > 1: print "Initializing dialogue took %g seconds.." % (time.time() - s)
        dlg.ShowModal()
        modified = {}
        for ID in dlg.modifiedDict:
            modified[ID] = dlg.toonDict[ID]
        
        dlg.Destroy()
        
        if len(modified) or needUpdate:
            Chars.SaveToonsDB(modified)     # Store any changes made
            self.Tab1_UpdateToonlist()
        
            
                
    # Attempt to find the latest modified log
    # Here we combine the toon list from Button1Manage with account list from the Chars module
    def Tab1_BLatest(self, event):
        accnames = Chars.GetAccFromID(False)
        if len(accnames) == 0:
            self.frame_1_statusbar.SetLabel("Could not detect any active toons")
            return
        
        # Compile list of (toon,id) for enabled toons
        tmpList = []
        for Key in self.activeToons:
            if not self.activeToons[Key]["Enabled"]: continue
            try: tmpList.append((accnames[Key], Key))
            except: pass
        
        # Grab the latest toon, based on enabled list
        latest = Chars.getLatestLog(tmpList)
            
        if latest == None:
            self.frame_1_statusbar.SetLabel("No logs detected, pacifist?")
            return
        
        self.frame_1_statusbar.SetLabel("Detected %s as the most recently played toon" % self.activeToons[latest]["Toon"])
        self.Tab1_UpdateRightsideInfo(id=latest)
 
        # Select toon in the listbox (otherwise somewhat annoying)
        idx = self.listbox1_toonlist.FindString(self.activeToons[latest]["Toon"])
        if idx != -1:
            self.listbox1_toonlist.SetSelection(idx)


        
    # Seperated as an independant function, as its called from both list-clicks + "latest"
    # This is the tab1 function, choosing your own toon
    def Tab1_UpdateRightsideInfo(self, Toon="", id=0):
        # If no ID provided, look by toon
        if id == 0:
            if not Toon: return -1
            for ID in self.activeToons:
                if self.activeToons[ID]["Toon"] == Toon:
                    id = ID
                    break
                

        ID = id
        Toon = self.activeToons[ID]["Toon"] # In case called by ID
        dim = self.activeToons[ID]["Dimension"]
        self.currentToon = Toon             # Anti-flicker
        self.currentToonID = ID             # Parsing etc

        self.label1_showid.SetLabel("%d" % ID)
        self.label1_showtoon.SetLabel("%s" % Toon)
        

        # Own toon, independant from any parsing!
        w = self.w.whois(Toon, dim)
        if not w[0] == "Mob?":
            self.label1_showlevel.SetLabel("%d" % w[2])
            self.label1_showclass.SetLabel(w[1])
        else:
            self.label1_showlevel.SetLabel("?")
            self.label1_showclass.SetLabel("?")                    
                
        


    # Save AO path / toons configurations to SQL
    # Unrelated to any tabs.
    def saveConfig(self):
        self._config["AllowMobs"]   = self.checkbox_4.IsChecked()
        self._config["AllowLowdmg"] = self.checkbox_5.IsChecked()
        self._config["webparse"]    = False
        self._config["HotkeyPause"] = self.Tab3_pause_instead_of_stop.IsChecked()
        Chars.SaveConfig(self._config)
        
        
    def OnClose(self, event):
        # Don't bother saving incorrect paths
        if not Chars.VerifyAO(self._config["AOPath"]):
            print "Deleting AO PATH: ", self._config["AOPath"]
            del self._config["AOPath"]
        else:
            s = Scripts.Script()
            s.AddOnlineStatus(False)            

        
        # Signal thread to stop
        try: self.p_tasks.put("Stop")
        except: pass
        
        # Stop any timers    
        try: self.p_timer.Stop()
        except: pass
        
        # Stop listening timer
        try: self.__ListenerTimer.Stop()
        except: pass
        
        # Save and terminate
        self.saveConfig()
        self.Destroy()
        
        
    def InitializeSQDB(self,aoPath, aoiaPath):
        # Load char data from SQL
        toonsDict = Chars.LoadToonsDB()
        modified = [] # Modified toon data, for storing.
          
        # Detect which characters, if any, are missing an account name.
        missingAccount = []
        for ID in toonsDict:
            if not toonsDict[ID]["Acc"]: missingAccount.append(ID)
        
        if len(missingAccount): print "[UI     ] Missing account name for %d toons" % len(missingAccount)
        


        # Grab account names from Prefs
        folderDict = Chars.GetAccFromID(False)
        for ID in folderDict:
            if ID in missingAccount: 
                missingAccount.remove(ID)                   # No longer missing
                toonsDict[ID]["Acc"] = folderDict[ID]       # Store acc name
                modified.append(ID)
                print "Got accname for ID=%d" % ID
                
            # Store newly found acc/ids
            if ID not in toonsDict:
                toonsDict[ID] = {"Toon":"", "Enabled": 0, "Acc":folderDict[ID], "Dimension":"RK1"}
                modified.append(ID)
                

        
        
        # Look for deleted toons..
        for ID in toonsDict:
            if ID not in folderDict:
                missingAccount.append(ID)
                
        
        # Grab character names from aoia
        # Overwrite only if no name currently exists
        aoiaDict = Chars.GetIdToonFromAOIA(aoiaPath)
        for ID in aoiaDict:
            if not ID in toonsDict: continue
            if not toonsDict[ID]["Toon"]:
                print "%d: Got new name from AOIA: %s" % (ID, aoiaDict[ID])     
                toonsDict[ID]["Toon"] = aoiaDict[ID]
                print toonsDict[ID]
                modified.append(ID)
                
        
                
        modifiedDict = {}
        for ID in modified: 
            modifiedDict[ID] = toonsDict[ID] 
                    
        # Delete any toons still without any account name
        for ID in missingAccount:
            del toonsDict[ID]
            modifiedDict[ID] = None
            print "Deleted toon with missing account data: %d" % ID
        
        # Store any changes
        self.__ThreadDBSave = Chars.DBThread(modifiedDict)
        self.__ThreadDBSave.start()
    
    def loadConfig(self):
        self._config = Chars.LoadConfig()
        pass
    
    def __set_properties(self):
        # begin wxGlade: MyFrame.__set_properties
        self.SetTitle("DDParser")
        self.frame_1_statusbar.SetStatusWidths([-1])
        # statusbar fields
        frame_1_statusbar_fields = [""]
        for i in range(len(frame_1_statusbar_fields)):
            self.frame_1_statusbar.SetStatusText(frame_1_statusbar_fields[i], i)
        self.listbox1_toonlist.SetMinSize((-1, 200))
        self.button1_manage.SetMinSize((-1, 20))
        self.button1_manage.SetToolTipString("Manage characters")
        self.button1_latest.SetMinSize((-1, 20))
        self.button1_latest.SetToolTipString("Detect last modified log")
        self.button1_parse.SetMinSize((-1, 20))
        self.button1_parse.SetToolTipString("Start/stop a new session")
        self.button1_pause.SetMinSize((-1, 20))
        self.button1_pause.SetToolTipString("Pause the current parse..")
        self.button1_pause.Enable(False)
        
        self.listbox2_history.SetMinSize((-1, 300))
        self.button_4_copy.SetMinSize((88, 20))
        self.button_4_copy.SetFocus()
        self.tab2_intoao.SetMinSize((-1, 20))
        self.tab2_intoao.SetToolTipString("Copy into AO's /dc command")
        
        
        self.tab2_editname.SetMinSize((88, 20))
        self.tab2_editname.SetToolTipString("Edit session name")
        self.tab2_delete_log.SetMinSize((-1, 20))
        self.label_1_copy.SetToolTipString("Path to AO installation")
        self.text_ctrl_3_aopath.SetMinSize((350, -1))
        self.text_ctrl_3_aopath.SetToolTipString("Path to AO installation")
        self.button3_browse_ao.SetMinSize((-1, 20))
        self.button3_browse_ao.SetToolTipString("Path to AO installation")
        self.button3_autodetect.SetMinSize((-1, 20))
        self.button3_autodetect.SetToolTipString("Autodetect AO / AOIA")
        self.Tab3_text_hotkeyMod.SetSelection(0)
        self.Tab3_pause_instead_of_stop.SetToolTipString("Pause the current parse instead of stopping it (on hotkey)")
        self.checkbox_4.SetToolTipString("Keep mobs in the parse")
        self.checkbox_5.SetToolTipString("Keep players with less than 1% damage")
        self.Tab3_Grouptype.SetToolTipString("Chatgroup, default uses active one.")
        self.Tab3_Grouptype.SetSelection(0)
        self.Tab3_Groupname.Enable(False)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MyFrame.__do_layout
        sizer_2_copy = wx.BoxSizer(wx.VERTICAL)
        sizer_4_copy = wx.BoxSizer(wx.VERTICAL)
        sizer_4 = wx.BoxSizer(wx.VERTICAL)
        sizer_3 = wx.BoxSizer(wx.VERTICAL)
        sizer_5 = wx.BoxSizer(wx.VERTICAL)
        sizer_6 = wx.BoxSizer(wx.VERTICAL)
        sizer_7 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_9_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_6_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_5_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_8_copy = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1 = wx.GridSizer(1, 2, 0, 0)
        grid_sizer_4 = wx.GridSizer(15, 2, 0, 0)
        sizer_7_copy = wx.BoxSizer(wx.VERTICAL)
        sizer_16_copy = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1_copy = wx.GridSizer(8, 3, 1, 0)
        sizer_17_copy = wx.BoxSizer(wx.VERTICAL)
        sizer_18_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_17_copy.Add(self.label_21_copy, 0, 0, 0)
        sizer_17_copy.Add(self.listbox1_toonlist, 0, 0, 0)
        sizer_18_copy.Add(self.button1_manage, 0, 0, 0)
        sizer_18_copy.Add(self.button1_latest, 0, 0, 0)
        sizer_17_copy.Add(sizer_18_copy, 1, wx.EXPAND, 0)
        sizer_16_copy.Add(sizer_17_copy, 1, wx.EXPAND, 0)
        grid_sizer_1_copy.Add(self.label_11_copy, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.label_12_copy, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.label1_showid, 0, 0, 0)
        grid_sizer_1_copy.Add(self.label_13_copy, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.label1_showtoon, 0, 0, 0)
        grid_sizer_1_copy.Add(self.label_14_copy, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.label1_showlevel, 0, 0, 0)
        grid_sizer_1_copy.Add(self.label_18_copy, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.label1_showclass, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        grid_sizer_1_copy.Add(self.button1_parse, 0, 0, 0)
        grid_sizer_1_copy.Add(self.button1_pause, 0, 0, 0)
        grid_sizer_1_copy.Add((5, 20), 0, 0, 0)
        
        sizer_16_copy.Add(grid_sizer_1_copy, 1, 0, 0)
        self.notebook_1_pane_1_copy.SetSizer(sizer_16_copy)
        sizer_7_copy.Add(self.listbox2_history, 0, 0, 0)
        sizer_7_copy.Add(self.button_4_copy, 0, 0, 0)
        grid_sizer_1.Add(sizer_7_copy, 1, wx.EXPAND, 0)
        grid_sizer_4.Add((10, 20), 0, 0, 0)
        grid_sizer_4.Add(self.tab2_chooseToon, 0, wx.EXPAND, 0)
        grid_sizer_4.Add(self.tab2_start, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_start, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_end, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_end, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_duration, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_duration, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_name, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_name, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_level, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_level, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_prof, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_prof, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_dmg, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_dmg, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_dpm, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_dpm, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_crit, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_crit, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_pets, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_pets, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_charms, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_out_charms, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_intoao, 0, 0, 0)
        
        grid_sizer_4.Add(self.tab2_editname, 0, 0, 0)
        grid_sizer_4.Add(self.tab2_delete_log, 0, 0, 0)
        grid_sizer_1.Add(grid_sizer_4, 1, wx.EXPAND, 0)
        self.notebook_1_pane_2_copy.SetSizer(grid_sizer_1)
        sizer_8_copy.Add(self.label_1_copy, 0, 0, 0)
        sizer_4_copy.Add(sizer_8_copy, 0, wx.EXPAND, 0)
        sizer_5_copy.Add(self.text_ctrl_3_aopath, 0, 0, 0)
        sizer_5_copy.Add((5, 1), 0, 0, 0)
        sizer_5_copy.Add(self.button3_browse_ao, 0, 0, 0)
        sizer_4_copy.Add(sizer_5_copy, 0, wx.EXPAND, 0)
        sizer_4_copy.Add(self.button3_autodetect, 0, 0, 0)
        sizer_4_copy.Add((20, 20), 0, 0, 0)
        sizer_6_copy.Add(self.label_2, 0, 0, 0)
        sizer_6_copy.Add((5, 1), 0, 0, 0)
        sizer_4_copy.Add(sizer_6_copy, 0, wx.EXPAND, 0)
        sizer_9_copy.Add(self.Tab3_text_hotkeyMod, 0, 0, 0)
        sizer_9_copy.Add(self.Tab3_text_hotkey, 0, 0, 0)
        sizer_4_copy.Add(sizer_9_copy, 0, wx.EXPAND, 0)
        sizer_6.Add(self.Tab3_pause_instead_of_stop, 0, 0, 0)
        sizer_6.Add((50, 25), 0, 0, 0)
        sizer_6.Add(self.checkbox_4, 0, 0, 0)
        sizer_6.Add(self.checkbox_5, 0, 0, 0)
        sizer_7.Add(self.Tab3_Grouptype, 0, 0, 0)
        sizer_7.Add(self.Tab3_Groupname, 0, 0, 0)
        sizer_6.Add(sizer_7, 1, wx.EXPAND, 0)
        sizer_5.Add(sizer_6, 1, wx.EXPAND, 0)
        sizer_3.Add(sizer_5, 1, wx.EXPAND, 0)
        sizer_4_copy.Add(sizer_3, 1, wx.EXPAND, 0)
        sizer_4_copy.Add(sizer_4, 1, wx.EXPAND, 0)
        self.notebook_1_pane_3_copy.SetSizer(sizer_4_copy)
        self.notebook_1_copy.AddPage(self.notebook_1_pane_1_copy, "Characters")
        self.notebook_1_copy.AddPage(self.notebook_1_pane_2_copy, "History")
        self.notebook_1_copy.AddPage(self.notebook_1_pane_3_copy, "Settings")
        sizer_2_copy.Add(self.notebook_1_copy, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_2_copy)
        sizer_2_copy.Fit(self)
        self.Layout()
        # end wxGlade



    def Listbox1Click(self, event): # wxGlade: MyFrame.<event_handler>
        toon = self.listbox1_toonlist.GetStringSelection()
        if not toon or self.currentToon == toon: #Prevents flickering on doubleclick
            return
        
        # Update right side info
        self.currentToon = toon
        self.Tab1_UpdateRightsideInfo(Toon=toon)
        
        



    def MenuExit(self, event): # wxGlade: MyFrame.<event_handler>
        return self.OnClose(0)
        

    def MenuAbout(self, event): # wxGlade: MyFrame.<event_handler>
        from DebugSettings import Build_ID, Build_Version
        data = """DcDump is a damage parser aimed at being accurate yet easy to use.
Author:            Eviltrox
Contributor:    Wolfbiter
Testers:           Doctaco238

Version %s.%d""" % (Build_Version, Build_ID)

        x = wx.MessageDialog(None, data, "About", style=wx.OK | wx.CENTRE)
        x.ShowModal()
        
    def Tab2SelHistory(self, event): # wxGlade: MyFrame.<event_handler>
        idx = self.listbox2_history.GetSelection()
        if idx == -1: return
        
        start = self.LoggerItems[idx][0]
        end = self.LoggerItems[idx][1]
        toon = self.LoggerItems[idx][2]
        
        data = self.DBLogger.getSingle(start, end, toon)

        # Update sessions data
        s = datetime.datetime.fromtimestamp(data["start"]).strftime("%d/%m/%Y, %H:%M")
        e = datetime.datetime.fromtimestamp(data["end"]).strftime("%d/%m/%Y, %H:%M")
        durM = (data["end"] - data["start"]) / 60
        durS = (data["end"] - data["start"]) - durM * 60
        self.tab2_out_start.SetLabel(s)
        self.tab2_out_end.SetLabel(e)
        self.tab2_out_duration.SetLabel("%dm:%ds" % (durM, durS))
        
        # Store session data
        self.CurrentData = data["data"]
        self.CurrentStats = data["stats"]
        self.CurrentPeriod = (data["start"], data["end"], data["end"] - data["start"])
        
        
        

    
    
        # Populate toon list, sort by damage done!
        from Scripts import sortByDamage
        self.tab2_chooseToon.Clear()
        
        dataset = sortByDamage(self.CurrentData)
        for Toon, crap in dataset:
            self.tab2_chooseToon.Append(Toon)

        self.tab2_chooseToon.SetSelection(0)
        self.Tab2ChooseToon(0)
        
        
    def Tab2PopulateHistory(self):
        self.listbox2_history.Set([])
        
        # (start, end, Toon, customName)
        self.LoggerItems = self.DBLogger.getAll()
        for I in self.LoggerItems:
            
            s = datetime.datetime.fromtimestamp(I[0]).strftime("%d/%m/%Y")
            if I[3]: # Custom name
                self.listbox2_history.Append("%s - %s" % (s, I[3]), 0)
            else: # Use toon name
                s = datetime.datetime.fromtimestamp(I[0]).strftime("%d/%m/%Y")
                self.listbox2_history.Append("%s - %s" % (s, I[2]), 0)
        

    def Tab2ChooseToon(self, event): # wxGlade: MyFrame.<event_handler>
        # Store session data
        Toon = self.tab2_chooseToon.GetStringSelection()
        
        # Verify that this is a valid toon
        w = self.CurrentData[Toon]["whois"]
        try:
            w[2]
        except:
            w = ("Mob?", "", 0) # This is a problem from old default data. - Doesnt exist anymore.

        if w[0] == "Mob?": self.frame_1_statusbar.SetLabel("Notice: Toon \"%s\" may be a pet or charm." % Toon)
        else: self.frame_1_statusbar.SetLabel("")

        try: critRate = self.CurrentData[Toon]["critHits"] / float(self.CurrentData[Toon]["hits"]) * 100
        except: critRate = 0
        
        try: dpm = float(self.CurrentData[Toon]["dmg"]) / (self.CurrentPeriod[2] / 60.)
        except ZeroDivisionError: dpm = 0
        
        try: critTotal = (self.CurrentData[Toon]["critAmount"] / float(self.CurrentData[Toon]["dmg"])) * 100
        except ZeroDivisionError: critTotal = -1
        
        dpm = Scripts.number_format(dpm)
        dmg = Scripts.number_format(self.CurrentData[Toon]["dmg"])
        
        # Fill right side labels
        self.tab2_out_name.SetLabel(Toon)
        self.tab2_out_level.SetLabel("%d" % w[2])
        self.tab2_out_prof.SetLabel(w[1])
        self.tab2_out_dmg.SetLabel("%s" % dmg)
        self.tab2_out_dpm.SetLabel("%s" % dpm)
        self.tab2_out_crit.SetLabel("%d%% (%d%% of damage)" % (critRate, critTotal))
        
        # Pets / charms only if exists
        if self.CurrentData[Toon]["pets"]:
            perc = float(self.CurrentData[Toon]["pets"]) / (0.1 + self.CurrentData[Toon]["dmg"])        # +0.1 to avoid any div0 
            self.tab2_out_pets.SetLabel("%s (%.f%%) " % (Scripts.number_format(self.CurrentData[Toon]["pets"]), perc * 100))
        else: self.tab2_out_pets.SetLabel("")
        
        try: 
            perc = float(self.CurrentData[Toon]["charms"]) / (0.1 + self.CurrentData[Toon]["dmg"])        # +0.1 to avoid any div0
            self.tab2_out_charms.SetLabel("%s (%.f%%) " % (Scripts.number_format(self.CurrentData[Toon]["charms"]), perc * 100))
            
        except KeyError: self.tab2_out_charms.SetLabel("")
        
        #
        

        
        
      

    def Tab2_EditSession(self, event): # wxGlade: MyFrame.<event_handler>
        idx = self.listbox2_history.GetSelection()
        if idx == -1:
            self.frame_1_statusbar.SetLabel("No log entry selected..")
            return
        
        # Grab current name and pass it to the dialog
        s, e, toon, cname = self.LoggerItems[idx]
        if cname == None: cname = ""
        
        # Open dialog for changing session name
        dlg = Diag_Tab2EditName(self)
        dlg.SetName(cname)
        if dlg.ShowModal() == wx.ID_OK:
            cname = dlg.GetName()
            if self.DBLogger.setCustomName(s, e, toon, cname):
                self.frame_1_statusbar.SetLabel("Session name updated.")
                self.Tab2PopulateHistory()
            else:
                self.frame_1_statusbar.SetLabel("Session name already taken..")
                
        dlg.Destroy()
        
        

    def Tab2_CopyToAO(self, event): # wxGlade: MyFrame.<event_handler>
        if not self._config["AOPath"]:
            self.frame_1_statusbar.SetLabel("Error: Anarchy online not found..")
        
        elif not isinstance(self.CurrentData, dict) or not isinstance(self.CurrentStats, dict):
            self.frame_1_statusbar.SetLabel("Error: Invalid data..")

        elif len(self.CurrentData) == 0 and len(self.CurrentStats) == 0:
            self.frame_1_statusbar.SetLabel("Error: No log selected?")
        else:                
            targetWindow = self._config["GroupType"]
            if targetWindow == 'Custom': targetWindow = self._config["GroupName"]
            s = Scripts.Script()
            if s.AddScripts(self.CurrentData, self.CurrentStats, self.CurrentPeriod, False, targetWindow):
                self.frame_1_statusbar.SetLabel("Now available via /Dc ingame!")
            else:
                self.frame_1_statusbar.SetLabel("Failed to write /dc scripts")
        
        
    def Tab2_ShowLatest(self, event, which=0): # wxGlade: MyFrame.<event_handler>
        """
        @param event: Ignored
        @param which: (start, end, toon)
        Selects the most recent fight, or specific by 'which'
        """
        i = 0
        if which:
            for Entry in self.LoggerItems: # can't use "in", 4th param is unknown
                if Entry[:3] == which: N = i
                i += 1
        else:
            N = len(self.LoggerItems) - 1

        self.listbox2_history.SetSelection(N) # -1 for [0,n-1] range, -1 for "?Tanks"
        self.Tab2SelHistory(0)
        

    def Tab2_DeleteLog(self, event): # wxGlade: MyFrame.<event_handler>
        idx = self.listbox2_history.GetSelection()
        if idx == -1:
            self.frame_1_statusbar.SetLabel("No log entry selected..")
            return
        
        
        # Delete entry
        s = self.LoggerItems[idx][0]
        e = self.LoggerItems[idx][1]
        t = self.LoggerItems[idx][2]
        self.DBLogger.deleteEntry(s, e, t)
        
        # Repopulate list
        self.Tab2PopulateHistory()
        
        # Erase current right-side data
        self.tab2_out_start.SetLabel("")
        self.tab2_out_end.SetLabel("")
        self.tab2_out_duration.SetLabel("")
        self.tab2_out_name.SetLabel("")
        self.tab2_out_level.SetLabel("")
        self.tab2_out_prof.SetLabel("")
        self.tab2_out_dmg.SetLabel("")
        self.tab2_out_dpm.SetLabel("")
        self.tab2_out_crit.SetLabel("")
        self.tab2_out_pets.SetLabel("")
        self.tab2_out_charms.SetLabel("")
        
        # Clear toon list (right side)
        self.tab2_chooseToon.Clear()
        
        self.frame_1_statusbar.SetLabel("Log entry deleted!")
        
    def Tab3_BrowseAO(self, event): # wxGlade: MyFrame.<event_handler>
        dirname = ""
        dlg = wx.FileDialog(self, "Choose a file", dirname, "", "Anarchy.exe", wx.OPEN)
        if dlg.ShowModal() == wx.ID_OK:
            dirname = dlg.GetDirectory()
            
            if os.access(dirname + "\\anarchy.exe", os.F_OK):
                self.frame_1_statusbar.SetLabel("Anarchy Online path stored")
                self._config["AOPath"] = dirname
                self.__Listener.setAOPath(self._config["AOPath"])
                self.text_ctrl_3_aopath.SetLabel(dirname + "\\")
                self.saveConfig()

            else:
                self.frame_1_statusbar.SetLabel("Invalid Anarchy Online path..")
        
        dlg.Destroy()


    def Tab3_EditPathAO(self, event):
        self._config["AOPath"] = self.text_ctrl_3_aopath.GetValue()
        self.__Listener.setAOPath(self._config["AOPath"])


    def Tab3_AutoDetect_AO(self, event):
           
        path = Chars.AutodetectAO()
        if not path == "-1":
            self.text_ctrl_3_aopath.SetLabel(path)
            self._config["AOPath"] = path
            self.__Listener.setAOPath(self._config["AOPath"])
            self.saveConfig()
            self.frame_1_statusbar.SetLabel("Anarchy Online detected!")
            
            self.InitializeSQDB(self._config["AOPath"], self._config["AOIAPath"])
        else:
            self.frame_1_statusbar.SetLabel("Could not detect Anarchy Online running..")
           

        



    def Tab3_SetHotkey(self, event=0): # wxGlade: MyFrame.<event_handler>
        """
        Event handler for hotkey changes
        """
        Keycode = self.Tab3_text_hotkey.GetLabel()
        # No code: disable hotkey
        if len(Keycode) == 0:
            self._config["Hotkey_Key"] = None
            self.RegHotkey()
            return
            
        # Maxlen: 1
        if len(Keycode) > 1: 
            Keycode = Keycode[0]
            self.Tab3_text_hotkey.SetLabel(Keycode)
            
        self._config["Hotkey_Key"] = Keycode
        self._config["Hotkey_Mod"] = self.Tab3_text_hotkeyMod.GetLabel()
        self.RegHotkey()
    
    def RegHotkey(self):
        """
        Registers a system wide hotkey, based on self_config settings
        """
        import win32con
        self.UnregisterHotKey(100) # Disable any existing hotkeys
        
        Modifier = self._config["Hotkey_Mod"]
        if Modifier == 'Alt':       Modifier = win32con.MOD_ALT
        elif Modifier == 'Shift':   Modifier = win32con.MOD_SHIFT
        else:                       Modifier = win32con.MOD_CONTROL
        Key = self._config["Hotkey_Key"]
     
        if Key == None or len(Key) == 0:
            print "Hotkey disabled" 
            return
        Key = ord(Key.upper())
        
        print "[UI     ] Hotkey registered:", self._config["Hotkey_Mod"], chr(Key)
        self.RegisterHotKey(100, Modifier, Key)
        self.Bind(wx.EVT_HOTKEY, self.handleHotKey, id=100)

    def handleHotKey(self, evt):
        if self.listbox1_toonlist.GetSelection() == -1:
            self.Tab1_BLatest(0)
        
        # If we couldnt find any logs, print an error.
        if self.listbox1_toonlist.GetSelection() != -1:
            if self.Tab3_pause_instead_of_stop.IsChecked():
                self.Tab1_BParse('Pause')
            else:
                self.Tab1_BParse(0)
        else:
            self.frame_1_statusbar.SetLabel("Could not hotkey-parse: No latest found")
            


    def MenuHelp(self, event):  # wxGlade: MyFrame.<event_handler>
        import webbrowser
        webbrowser.open('http://ribbs.dreamcrash.org/minitutorial/')


    '''
    Updates the internal settings variables with group type
    If the parser is currently running, it updates the target window.
    '''
    def Tab3_GroupType(self, event):  # wxGlade: MyFrame.<event_handler>
        str = self.Tab3_Grouptype.GetStringSelection()
        if str == 'Custom': 
            self.Tab3_Groupname.Enable(True)
            if self.parser != 0 and self.parser.isAlive(): self.parser.setTargetWindow(self._config["GroupName"])
            self.__Listener.setTargetWindow(self._config["GroupName"])
        else: 
            self.Tab3_Groupname.Enable(False)
            if self.parser != 0 and self.parser.isAlive(): self.parser.setTargetWindow(str)
            self.__Listener.setTargetWindow(str)
        self._config["GroupType"] = str

    def Tab3_GroupName(self, event):  # wxGlade: MyFrame.<event_handler>
        if not self.Tab3_Grouptype.GetString(self.Tab3_Grouptype.GetCurrentSelection()) == 'Custom': return
        self._config["GroupName"] = self.Tab3_Groupname.GetLabelText()
        self.__Listener.setTargetWindow(self._config["GroupName"])
        if self.parser != 0 and self.parser.isAlive():
            self.parser.setTargetWindow(self._config["GroupName"])
         
        

# end of class MyFrame


class MyApp(wx.App):
    def OnInit(self):
        #wx.InitAllImageHandlers()
        frame_1 = MyFrame(None, -1, "")
        self.SetTopWindow(frame_1)
        frame_1.Show()
        return 1

# end of class MyApp

if __name__ == "__main__":
    from multiprocessing import Process, freeze_support
    freeze_support()
    
        
    # Just adding new ID:toons, not starting the program
    from sys import argv, exit
    if len(argv) == 4 and argv[1] == 'update':
        import sys, Tests
        #Tests.enableLogging()
        id = int(argv[2])
        nick = argv[3]
        from Chars import UpdateToonsDB
        UpdateToonsDB(id, nick)
        print argv
        exit(0)
    
    if len(argv) > 1 and argv[1] == 'test':
        import Tests
        Tests.runTests()
        exit(0)
        
    if len(argv) > 1 and argv[1] == 'log':
        import Tests
        Tests.enableLogging()
    
    app = MyApp(0)
    app.MainLoop()
